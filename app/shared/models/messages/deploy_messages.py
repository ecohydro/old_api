from . import Message
from .. import g


class DeployMessage(Message):

    def __init__(self, message=None):
        super(DeployMessage, self).__init__()
        self.type = 'deploy'
        self.frame = self.__class__.__name__
        self.format.extend([
            {'name': 'mcc', 'length': 3},
            {'name': 'mnc', 'length': 3},
            {'name': 'lac', 'length': 4},
            {'name': 'cell_id', 'length': 4},
            {'name': 'voltage', 'length': 8},
            {'name': 'n_sensors', 'length': 2},
        ])
        if message is not None:
            self.init(message=message)

    def create_fake_message(self, frame_id=3, notebook=None):
        """
        Create a fake message for use in testing/debugging

        :param frame_id: Message frame id. Should be 3 for deploy
        :param notebook: The (fake) notebook that this message will
                        be built on. Should be generated by the
                        Message.generate_fake_message function.

        Returns a fake deploy message based on the current notebook and
        some dummy location information.

            mcc = 310
            mnc = 26
            lac = 802
            cell_id = 10693
            n_sensors = 3

        Sensors are selected randomly from the Sensor db.

        """
        deploy_str = self.create_fake_header(frame_id, notebook)
        import struct
        from random import random, sample
        from ..sensor import Sensor
        mcc = 310
        mnc = 26
        lac = 802
        cell_id = 10693
        n_sensors = 3
        voltage = struct.pack(
            '<f',
            float(3.6 + random() / 2)).encode('hex').zfill(
            self.get_length('voltage'))
        sensors = sample(Sensor.objects(), n_sensors)
        deploy_str += ('%i' % int(mcc)).zfill(self.get_length('mcc'))
        deploy_str += ('%i' % int(mnc)).zfill(self.get_length('mnc'))
        deploy_str += ('%x' % int(lac)).zfill(self.get_length('lac'))
        deploy_str += ('%x' % int(cell_id)).zfill(
            self.get_length('cell_id'))
        deploy_str += voltage
        deploy_str += ('%x' % int(n_sensors)).zfill(
            self.get_length('n_sensors'))
        deploy_str += ''.join(
            [('%x' % int(x)).zfill(self.SID_LENGTH) for x in
                [str(sensor.sid) for sensor in sensors]])
        return deploy_str

    def new_nbk_id(self):
        import uuid
        # For deployment message, generate a random string:
        return str(uuid.uuid4())

    def mcc(self):
        (start, end) = self.get_position('mcc')
        if self.content:
            try:
                return int(self.content[start:end])
            except ValueError as e:
                e.args += ('message content invalid', 'DeployMessage', 'mcc()')
                raise
        else:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, "Uh-oh. No message content."

    def mnc(self):
        (start, end) = self.get_position('mnc')
        if self.content:
            try:
                return int(self.content[start:end])
            except ValueError as e:
                self.message.status = 'invalid'
                self.message.save()
                e.args += ('message content invalid', 'DeployMessage', 'mnc()')
                raise
        else:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, "Uh-oh. No message content."

    def lac(self, tower_number=1):
        (start, end) = self.get_position('lac')
        if self.content:
            try:
                return int(self.content[start:end], 16)
            except ValueError as e:
                e.args += ('message content invalid', 'DeployMessage', 'lac()')
                raise
        else:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, "Uh-oh. No message content."

    def cell_id(self, tower_number=1):
        (start, end) = self.get_position('cell_id')
        if self.content:
            try:
                return int(self.content[start:end], 16)
            except ValueError as e:
                self.status = 'invalid'
                e.args += ('message content invalid',
                           'DeployMessage',
                           'cell_id()')
                raise
        else:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, "Uh-oh. No message content."

    def tower_length(self):
        return self.get_length('cell_id') + self.get_length('lac')

    def voltage(self):
        import struct
        (start, end) = self.get_position('voltage')
        if self.content and len(self.content) >= end:
            try:
                return struct.unpack(
                    '<f',
                    self.content[start:end].decode('hex'))[0]
            except ValueError as e:
                self.message.status = 'invalid'
                self.message.save()
                e.args += ('message content invalid',
                           'DeployMessage',
                           'voltage()')
                raise
        else:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, "Uh-oh. No message content."

    def n_sensors(self):
        (start, end) = self.get_position('n_sensors')
        if self.content:
            try:
                return int(self.content[start:end], 16)
            except ValueError as e:
                self.message.status = 'invalid'
                self.message.save()
                e.args += ('message content invalid',
                           'DeployMessage',
                           'n_sensors()')
                raise
        else:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, "Uh-oh. No message content."

    def get_sensors(self):
        from ..sensor import Sensor
        i = self.format_length()
        sensors = []
        if len(self.content) < i:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, 'message content length=' + str(len(self.content)) + \
                      '. Must be >' + str(i)
            return
        elif len(self.content) != (i + self.SID_LENGTH * self.n_sensors()):
            self.message.status = 'invalid'
            self.message.save()
            assert 0, 'message content length=' + str(len(self.content)) + \
                      '. Must equal ' + \
                      str(i + self.SID_LENGTH * self.n_sensors())
            return

        try:
            for j in range(self.n_sensors()):
                sid = int(self.content[i:i + self.SID_LENGTH], 16)
                sensor = Sensor.objects(sid=sid).first()
                sensors.append(sensor)
                i += self.SID_LENGTH
        except:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, 'error reading sensor from database'
        return sensors

    def default_name(self, address):
        return str(self.pod['name']) + ' data from ' + \
            address['locality']['short'] + ', ' + \
            address['administrative_area_level_1']['short'] + \
            ' in ' + address['country']['short']

    def make_tower(self):
        try:
            return {
                'locationAreaCode': self.lac(),
                'cellId': self.cell_id(),
                'mobileNetworkCode': self.mnc(),
                'mobileCountryCode': self.mcc()
            }
        except:
            self.message.status = 'invalid'
            self.message.save()
            assert 0, 'error extracting cell info from message content'

    def slack(self):
        from app import mqtt_q, slack
        msg = ''
        msg += 'Deployed {pod} (SN:{pod_id}) owned by {owner}.\n'.format(
            pod=self.pod.name,
            pod_id=self.pod.pod_id,
            owner=self.pod.owner.username)
        msg += '"{notebook}" is now recording {sensors}.\n'.format(
            sensors=', '.join([str(x.name) for x in self.notebook.sensors]),
            notebook=self.notebook.name)
        msg += 'Current pod voltage is {voltage}.\n'.format(
            voltage=self.notebook.voltage)
        mqtt_q.enqueue(
            slack.chat.post_message,
            "#api",
            msg,
            username='api.pulsepod',
            icon_emoji=':pig:'
        )

    def create_alert(self, notebook):
        alert1 = 'Hi %s! ' % notebook.owner['username']
        alert1 += 'You just deployed your pod, %s, near %s.' % (
            notebook.pod['name'],
            notebook.address['formatted_address'],
        )
        link = 'https://app.pulsepod.io/notebook/%s' % notebook.get_id()
        alert2 = ' Data from this pod will now be recorded at %s.' % link
        return (alert1, alert2)

    def parse(self):
        from ..notebook import Notebook
        import datetime
        if self.status is not 'invalid':
            try:
                # Using Google API object
                location = g.tower_locate([self.make_tower()])
                elevation = g.elevation(location)
                address = g.geocode(location)
            except:
                self.message.status = 'invalid'
                self.message.save()
                assert 0, 'MessageParse: Error in Google API functions'
            try:
                notebook = Notebook(
                    pod_id=self.pod['pod_id'],
                    pod=self.pod,
                    sensors=self.get_sensors(),
                    sids=[sensor.sid for sensor in self.get_sensors()],
                    owner=self.pod['owner'],
                    last=datetime.datetime.utcnow(),
                    voltage=self.voltage(),
                    location=location,
                    elevation=elevation,
                    address=address,
                    name=self.default_name(address),
                    nbk_id=self.new_nbk_id(),
                    created_at=datetime.datetime.utcnow(),
                    confirmed=False
                )
                self.message.status = 'parsed'
                self.notebook = notebook
                self.message.save()
            except:
                assert 0, 'MessageParse: Error creating new notebook'
                self.message.status = 'invalid'
                self.message.save()

    def post(self):
        from ..pod import Pod
        from ..user import User
        from app import mqtt_q, slack
        slack_post = ''
        if self.status is not 'posted':
            try:
                self.notebook.save()
                Pod.objects(id=self.pod.id).update_one(
                    inc__notebooks=1,
                    set__current_notebook=self.notebook,
                    set__number=self.number
                )
                User.objects(id=self.pod.owner.id).update_one(
                    inc__notebooks=1
                )
                self.message.status = 'posted'
                self.message.save()
                slack_post += "Added notebook %s to the database\n" % \
                    self.notebook.__repr__()
                slack_post += "Incremented notebooks for %s and %s\n" % \
                    (self.pod.__repr__(), self.pod.owner.__repr__())
                slack_post += "Changed current notebook on %s to %s\n" % \
                    (self.pod.__repr__(), self.notebook.__repr__())
                mqtt_q.enqueue(
                    slack.chat.post_message,
                    "#oplog",
                    slack_post,
                    username='api.pulsepod',
                    icon_emoji=':computer:'
                )
            except:
                assert 0, 'MessageParse: Error saving new notebook'
            if self.notebook.owner.phone_number:
                pass
                # alerts = self.create_alert(self.notebook)
                # for alert in alerts:
                #     self.message.send_message(
                #         number=self.notebook.owner.phone_number,
                #         content=alert
                #     )
            elif 'email' in dir(self.notebook.owner):
                print 'sending deploy alert email [NOT FUNCTIONAL]'
            else:
                print "no user data available for alerts"
        else:
            return "message already posted"
